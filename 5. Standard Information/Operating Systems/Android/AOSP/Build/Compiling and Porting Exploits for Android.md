## Overview

This guide outlines the process of building and porting Android exploits, offering insights into understanding vulnerabilities, cross-compiling code, analyzing firmware, and adapting exploits to different devices. By leveraging tools such as the Android Native Development Kit (NDK) and kernel symbolization utilities, security researchers can effectively develop and customize exploits.

---

## Key Topics

### 1. **Cross-Compiling Using Android NDK**

#### Objective:

Enable cross-compilation of native C/C++ code or exploits for Android devices targeting specific architectures (ARM32, ARM64).

#### Steps:

1. **Install and Configure Android NDK**:
    
    - Download the NDK from [NDK Downloads](https://developer.android.com/ndk/downloads) or install via Android Studio:
        - Go to **File > Settings > SDK Tools**.
        - Select **NDK (side-by-side)** and **CMake**, then apply changes.
    - Add NDK binaries to the system's `PATH` for command-line access.
2. **Compile Example Code**:
    
    - Write a simple program (`hello.c`):
        
        c
        
        CopyEdit
        
        `#include <stdio.h> int main() {     printf("Hello, World!\n");     return 0; }`
        
    - Use `clang` for cross-compilation:
        
        bash
        
        CopyEdit
        
        `clang --target=aarch64-linux-android30 hello.c -o hello`
        
    - Transfer and test the binary:
        
        bash
        
        CopyEdit
        
        `adb push hello /data/local/tmp adb shell cd /data/local/tmp ./hello`
        
    - Verify the output (`Hello, World!`).

---

### 2. **Adapting Exploits to Different Devices**

#### Case Study: CVE-2020-0041

- **Objective**: Port a local privilege escalation exploit targeting Pixel 3 devices to Pixel 3a XL devices with similar hardware but different firmware.

#### Process:

1. **Understand the Exploit**:
    
    - Review hardcoded offsets and determine hardware/kernel dependencies.
    - Identify functions and parameters that require modification.
2. **Gather Target Device Information**:
    
    - Use `adb shell getprop` to retrieve build fingerprint and firmware details.
    - Download the corresponding OTA firmware from [Android OTA Repository](https://developers.google.com/android/ota).
3. **Update Exploit Offsets**:
    
    - Extract and analyze the target kernel to calculate updated offsets (described below).

---

### 3. **Kernel and Firmware Analysis**

#### Extract Firmware:

1. **Download OTA and Extract Files**:
    
    - Use `wget` to download the OTA file.
    - Use `extract_android_ota_payload.py` to extract firmware images, including `boot.img`:
        
        bash
        
        CopyEdit
        
        `python3 extract_android_ota_payload.py --input <ota-file> --output <output-dir>`
        
2. **Extract Kernel from Boot Image**:
    
    - Use `Android Boot Image Editor` ([GitHub Repository](https://github.com/cfig/Android_boot_image_editor)) to extract kernel data:
        
        bash
        
        CopyEdit
        
        `./gradlew unpack --input boot.img --output extracted-kernel`
        
3. **Decompress the Kernel**:
    
    - If compressed (e.g., LZ4), decompress the kernel:
        
        bash
        
        CopyEdit
        
        `lz4 -d kernel.lz4 kernel-decompressed`
        

#### Symbolize Kernel:

1. **Convert Kernel to ELF Format**:
    
    - Use `vmlinux-to-elf` for symbolization:
        
        bash
        
        CopyEdit
        
        `./vmlinux-to-elf kernel-decompressed -o kernel-symbolicated.elf`
        
2. **Analyze Kernel**:
    
    - Load the ELF file into Ghidra:
        
        bash
        
        CopyEdit
        
        `ghidraRun`
        
    - Search for relevant symbols (e.g., `selinux_enforcing`) to identify memory addresses.

---

### 4. **Offset Calculation**

#### Steps:

1. **Locate Kernel Base**:
    
    - Find the `_text` section in Ghidra to determine the kernel base address.
2. **Identify Symbol Addresses**:
    
    - Search for required symbols and record their memory addresses.
3. **Calculate Offsets**:
    
    - Compute the offset of each symbol relative to the kernel base:
        
        python
        
        CopyEdit
        
        `print(hex(symbol_address - kernel_base_address))`
        
4. **Integrate Offsets into Exploit**:
    
    - Replace hardcoded values in the exploit source code with the newly calculated offsets.

---

### 5. **Compile and Deploy the Exploit**

#### Compilation:

1. Modify the `Android.mk` file:
    - Disable security flags if necessary:
        
        makefile
        
        CopyEdit
        
        `LOCAL_CFLAGS += -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0`
        
2. Compile using `ndk-build`:
    
    bash
    
    CopyEdit
    
    `ndk-build`
    

#### Deployment and Testing:

1. Push the exploit binary to the target device:
    
    bash
    
    CopyEdit
    
    `adb push poc /data/local/tmp`
    
2. Run the exploit:
    
    bash
    
    CopyEdit
    
    `adb shell cd /data/local/tmp ./poc`
    
3. Verify success:
    - Check for root shell (`id` should return `uid=0`).
    - Access restricted directories (e.g., `/data/data`, `/sdcard`).

---

### 6. **Debugging and Validation**

#### Common Errors:

1. **Incorrect Offsets**:
    - Recalculate offsets if the exploit crashes or fails.
2. **FORTIFY Restrictions**:
    - Ensure the `LOCAL_CFLAGS` disables `FORTIFY` checks.
3. **Unexpected Device Behavior**:
    - Investigate logs for additional clues.

#### Validation:

- Confirm root privileges using `id`.
- Verify access to restricted paths such as `/data/data`.

---

## Summary

This guide equips security researchers with:

- Skills to compile and port Android exploits.
- Methods to analyze firmware and kernel files for effective customization.
- Techniques to debug and validate exploits.

These practices are vital for advancing Android security research and tailoring exploits to diverse device configurations.