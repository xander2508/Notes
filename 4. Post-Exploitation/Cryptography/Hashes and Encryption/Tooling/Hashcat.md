---
tags:
  - Post-Exploitation
  - Cryptography
  - HashesAndEncryption
  - Tooling
---
Example hashes and their associated Hashcat number can be found: [Example Hashes](https://hashcat.net/wiki/doku.php?id=example_hashes)

## Man Page

[Hashcat wiki](https://hashcat.net/wiki/doku.php?id=hashcat)

## Benchmark Modes

```shell-session
hashcat -b -m 0
```

For example, the hash rate for MD5 on a given CPU could be found as 450.7 MH/s.

### Optimizations

|                   |                                                                                                                                                                                                                                                                                                                                                                                                |
| ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Optimized Kernels | This is the `-O` flag, which according to the documentation, means `Enable optimized kernels (limits password length)`. The magical password length number is generally 32, with most wordlists won't even hit that number. This can take the estimated time from days to hours, so it is always recommended to run with `-O` first and then rerun after without the `-O` if your GPU is idle. |
| Workload          | This is the `-w` flag, which, according to the documentation, means `Enable a specific workload profile`. The default number is `2`, but if you want to use your computer while Hashcat is running, set this to `1`. If you plan on the computer only running Hashcat, this can be set to `3`.                                                                                                 |
|                   |                                                                                                                                                                                                                                                                                                                                                                                                |

---

## Attack Modes

- [Dictionary attack](https://hashcat.net/wiki/doku.php?id=dictionary_attack "dictionary_attack") - Trying all words in a list; also called “straight” mode (attack mode 0, `-a 0`)
- [Combinator attack](https://hashcat.net/wiki/doku.php?id=combinator_attack "combinator_attack") - Concatenating words from multiple wordlists (`-a 1`)
- [Brute-force attack](https://hashcat.net/wiki/doku.php?id=mask_attack "mask_attack") and [Mask attack](https://hashcat.net/wiki/doku.php?id=mask_attack "mask_attack") - trying all characters from given charsets, per position (`-a 3`)
- [Hybrid attack](https://hashcat.net/wiki/doku.php?id=hybrid_attack "hybrid_attack") - Combining wordlists + masks (`-a 6`) and masks + wordlists (`-a 7`); can [also be done with rules](https://hashcat.net/wiki/doku.php?id=toggle_attack_with_rules "toggle_attack_with_rules")
- [Association attack](https://hashcat.net/wiki/doku.php?id=association_attack "association_attack") - Use an username, a filename, a hint, or any other pieces of information which could have had an influence in the password generation to attack one specific hash (`-a 9`)

### Straight or Dictionary Attack

As the name suggests, this attack reads from a wordlist and tries to crack the supplied hashes. Dictionary attacks are useful if you know that the target organization uses weak passwords or just wants to run through some cracking attempts rather quickly. This attack is typically faster to complete than the more complex attacks discussed later in this module. It's basic syntax is:

```shell-session
hashcat -O -a 0 -m <hash type> <hash file> <wordlist>
```

## Combination Attack

The combination attack modes take in two wordlists as input and create combinations from them. This attack is useful because it is not uncommon for users to join two or more words together, thinking that this creates a stronger password, i.e., `welcomehome` or `hotelcalifornia`.

```shell-session
hashcat -a 1 -m <hash type> <hash file> <wordlist1> <wordlist2>
```

## Mask Attack

Mask attacks are used to generate words matching a specific pattern. This type of attack is particularly useful when the password length or format is known. A mask can be created using static characters, ranges of characters (e.g. [a-z] or [A-Z0-9]), or placeholders. The following list shows some important placeholders:

| **Placeholder** | **Meaning**                                             |
| --------------- | ------------------------------------------------------- |
| ?l              | lower-case ASCII letters (a-z)                          |
| ?u              | upper-case ASCII letters (A-Z)                          |
| ?d              | digits (0-9)                                            |
| ?h              | 0123456789abcdef                                        |
| ?H              | 0123456789ABCDEF                                        |
| ?s              | special characters («space»!"#$%&'()*+,-./:;<=>?@[]^_`{ |
| ?a              | ?l?u?d?s                                                |
| ?b              | 0x00 - 0xff                                             |
The above placeholders can be combined with options "`-1`" to "`-4`" which can be used for custom placeholders. See the _Custom charsets_ section [here](https://hashcat.net/wiki/doku.php?id=mask_attack) for a detailed breakdown of each of these four command-line parameters that can be used to configure four custom charsets.

The "`--increment`" flag can be used to increment the mask length automatically, with a length limit that can be supplied using the "`--increment-max`" flag.

```shell-session
hashcat -a 3 -m 0 md5_mask_example_hash -1 01 'ILFREIGHT?l?l?l?l?l20?1?d'
```

Hashcat reads words from the wordlist and appends a unique string based on the mask supplied. In this case, the mask "`?d?s`" tells Hashcat to append a digit and a special character at the end of each word in the `rockyou.txt` wordlist.

```shell-session
hashcat -a 6 -m 0 hybrid_hash /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt '?d?s'
```

Attack mode "`7`" can be used to prepend characters to words using a given mask.

## Hybrid Mode

Hybrid mode is a variation of the combinator attack, wherein multiple modes can be used together for a fine-tuned wordlist creation. This mode can be used to perform very targeted attacks by creating very customized wordlists. It is particularly useful when you know or have a general idea of the organization's password policy or common password syntax.

```shell-session
hashcat -a 6 -m 0 hybrid_hash /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt '?d?s'
```

 In this case, the mask "`?d?s`" tells Hashcat to append a digit and a special character at the end of each word in the `rockyou.txt` wordlist.
 
```shell-session
hashcat -a 7 -m 0 hybrid_hash_prefix -1 01 '20?1?d' /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt
```

Attack mode "`7`" can be used to prepend characters to words using a given mask. The following example shows a mask using a custom character set to add a prefix to each word in the `rockyou.txt` wordlist.

## Rules Based

The rule-based attack is the most advanced and complex password cracking mode. Rules help perform various operations on the input wordlist, such as prefixing, suffixing, toggling case, cutting, reversing, and much more. Rules take mask-based attacks to another level and provide increased cracking rates. Additionally, the usage of rules saves disk space and processing time incurred as a result of larger wordlists.

If a prospective password is known to be a variant of a specific pattern we can use rules to vary a known password.

A rule can be created using functions, which take a word as input and output it's modified version. The following table describes some functions which are compatible with JtR as well as Hashcat.

| **Function**    | **Description**                                                    | **Input**                             | **Output**                                                                                                        |
| --------------- | ------------------------------------------------------------------ | ------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| l               | Convert all letters to lowercase                                   | InlaneFreight2020                     | inlanefreight2020                                                                                                 |
| u               | Convert all letters to uppercase                                   | InlaneFreight2020                     | INLANEFREIGHT2020                                                                                                 |
| c / C           | capitalize / lowercase first letter and invert the rest            | inlaneFreight2020 / Inlanefreight2020 | Inlanefreight2020 / iNLANEFREIGHT2020                                                                             |
| t / TN          | Toggle case : whole word / at position N                           | InlaneFreight2020                     | iNLANEfREIGHT2020                                                                                                 |
| d / q / zN / ZN | Duplicate word / all characters / first character / last character | InlaneFreight2020                     | InlaneFreight2020InlaneFreight2020 / IInnllaanneeFFrreeiigghhtt22002200 / IInlaneFreight2020 / InlaneFreight20200 |
| { / }           | Rotate word left / right                                           | InlaneFreight2020                     | nlaneFreight2020I / 0InlaneFreight202                                                                             |
| ^X / $X         | Prepend / Append character X                                       | InlaneFreight2020 (^! / $! )          | !InlaneFreight2020 / InlaneFreight2020!                                                                           |
| r               | Reverse                                                            | InlaneFreight2020                     | 0202thgierFenalnI                                                                                                 |
A complete list of functions can be found [here](https://hashcat.net/wiki/doku.php?id=rule_based_attack#implemented_compatible_functions).

Sometimes, the input wordlists contain words that don't match our target specifications. For example, a company's password policy might not allow users to set passwords less than 7 characters in length. In such cases, rejection rules can be used to prevent the processing of such words.

Words of length less than N can be rejected with `>N`, while words greater than N can be rejected with `<N`. A list of rejection rules can be found [here](https://hashcat.net/wiki/doku.php?id=rule_based_attack#rules_used_to_reject_plains).

> [!NOTE]
> Reject rules only work either with `hashcat-legacy`, or when using `-j` or `-k` with `Hashcat`. They will not work as regular rules (in a rule file) with `Hashcat`.

Good rules for variation:
1. [Hob0Rules](https://github.com/praetorian-inc/Hob0Rules)
2. [best64.rule](https://github.com/samirettali/password-cracking-rules/blob/master/best64.rule)
3. [GitHub - NSAKEY/nsa-rules: Password cracking rules and masks for hashcat](https://github.com/NSAKEY/nsa-rules)
4. [HackLikeALegend/old/chap3/corporate.rule at master · sparcflow/HackLikeALegend · GitHub](https://github.com/sparcflow/HackLikeALegend/blob/master/old/chap3/corporate.rule)
5. [hashcat/rules/d3ad0ne.rule at master · hashcat/hashcat · GitHub](https://github.com/hashcat/hashcat/blob/master/rules/d3ad0ne.rule)

#### Default Existing Rules

```shell-session
ls /usr/share/hashcat/rules/
```
#### Word List Generation

```shell-session
hashcat --force password.list -r custom.rule --stdout | sort -u > mut_password.list
```

#### Usage 

```shell-session
hashcat -a 0 -m 100 hash /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt -r rule.txt
```
#### Example Rules

```shell-session
c so0 si1 se3 ss5 sa@ $2 $0 $1 $9
```

The first letter word is capitalized with the `c` function. Then rule uses the substitute function `s` to replace `o` with `0`, `i` with `1`, `e` with `3` and a with `@`. At the end, the year `2019` is appended to it.






---
## Example Commands

```
hashcat -m 13100 -a 0 GetUserSPNs.out /usr/share/wordlists/rockyou.txt
```

```
hashcat -m 300 -a 0 hash /usr/share/wordlists/rockyou.txt -r OneRuleToRuleThemAll.rule --debug-mode=1 --debug-file=matched.rule
```
### IPMI

Mode `7300`

In the event of an HP iLO using a factory default password, we can use this Hashcat mask attack command:
```
hashcat -m 7300 ipmi.txt -a 3 ?1?1?1?1?1?1?1?1 -1 ?d?u
```

Otherwise:

```shell-session
hashcat -m 7300 -w 3 -O "HASH" /usr/share/wordlists/rockyou.txt
```

### NT Hashes 

For hashes from Windows and SAM files.

```shell-session
sudo hashcat -m 1000 hashestocrack.txt /usr/share/wordlists/rockyou.txt
```