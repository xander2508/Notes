## **ARM 64 Calling Convention**

### **Function Arguments**

- In the ARM 64 architecture:
    - The **first 8 arguments** of a function are passed using **registers X0 to X7**.
        - These registers act as temporary storage for function arguments, which avoids the overhead of accessing memory.
        - **Example**: If a function `func(a, b, c)` is called:
            - `a` → `X0`
            - `b` → `X1`
            - `c` → `X2`
    - **Additional arguments** (more than 8) are passed onto the **stack**:
        - The stack is used for parameters when there are more arguments than registers available.
        - This allows ARM 64 to efficiently handle variable-length arguments.

### **Function Return**

- **Return Values**:
    - For **64-bit values**, the result is stored in **X0**.
        - Example: If a function returns `42`, `X0` holds `42`.
    - For **128-bit values**, results span **X0 + X1**:
        - These two registers combined allow the storage of larger results, such as large strings or structures.
- **Link Register (X30)**:
    - The **Link Register** stores the **return address** of the function call.
    - When the function completes, control resumes at the instruction address stored in `X30`.

---

## **Branch Instructions**

### **1. B (Branch)**

- The `B` instruction performs an **unconditional jump** to a specific address.
- This instruction is primarily used for simple control flow, such as loops or infinite jumps.
- **Syntax**: `B label`
    - `label` specifies the target address to branch to.

### **2. BL (Branch with Link)**

- The `BL` instruction is used to call a **subroutine** (a function or method).
- It saves the **address of the next instruction** (the return point) into **X30 (Link Register)**.
- This ensures the program knows where to resume execution after the subroutine completes.
- **Syntax**: `BL label`
- **Example**:
    - assembly
        
        Copy code
        
        `BL my_function  ; Call my_function`
        

### **3. BR (Branch to Register)**

- **Purpose**: The `BR` instruction branches to an **address** stored in a register.
- **Use Case**: Dynamic branching where the target address is not fixed but calculated or stored in a register.
- **Syntax**: `BR Xn`
    - Example: `BR X8` jumps to the address contained in `X8`.

### **4. BLR (Branch with Link to Register)**

- **Purpose**: Similar to `BL`, but branches to an **address in a register**.
- The **next instruction’s address** is saved to **X30**.
- **Use Case**: Indirect function calls or callbacks.
- **Syntax**: `BLR Xn`
- **Example**:
    - assembly
        
        Copy code
        
        `BLR X9  ; Call address stored in X9`
        

### **5. RET (Return)**

- The `RET` instruction transfers control back to the calling function by **jumping to the address in X30**.
- If `X30` has been modified, `RET` can jump to a custom address.
- **Use Case**: Completing a subroutine.
- **Syntax**: `RET`
- **Example**:
    - assembly
        
        Copy code
        
        `RET  ; Return to caller`
        

---

## **ARM 64 Registers Overview**

### **General-Purpose Registers**

#### **X0 to X7**

- These registers serve two primary purposes:
    1. **Argument Passing**: Hold the first 8 function arguments.
    2. **General Storage**: Temporary storage for variables or addresses.

#### **X8 to X28**

- These are additional **general-purpose registers**.
- Commonly used for intermediate computations, storing local variables, or holding addresses during program execution.

#### **X29 (Frame Pointer)**

- **Purpose**:
    - Points to the **bottom of the current stack frame**.
    - Enables easy access to **local variables** and function parameters stored on the stack.
- **Use Case**:
    - The frame pointer provides a stable reference point for variables in stack frames.

#### **X30 (Link Register)**

- **Purpose**:
    - Stores the **return address** when a subroutine is called.
    - After the subroutine finishes, the `RET` instruction uses `X30` to jump back to the caller.

#### **X31 (Stack Pointer / Zero Register)**

- **Dual-Purpose**:
    - Acts as:
        1. **Stack Pointer (SP)**: Points to the **top of the current stack**.
        2. **Zero Register**: Always returns a value of `0`.

---

### **Special-Purpose Registers**

#### **Program Counter (PC)**

- **Purpose**: Holds the address of the **next instruction** to execute.
- **Behavior**:
    - Instructions are fetched and executed sequentially.
    - Branch or jump instructions modify the PC to alter control flow.

#### **CPSR (Current Program Status Register)**

- **Purpose**:
    - Holds processor **flags** that describe the current state.
- **Flags**:
    - **Zero Flag**: Indicates a result of `0`.
    - **Negative Flag**: Set if a result is negative.
    - **Overflow Flag**: Set if arithmetic overflow occurs.

---

## **Memory Addressing**

### **Load-Store Model**

- ARM 64 follows a **Load-Store architecture**, meaning:
    - **Memory** can only be accessed using **explicit load (LDR)** and **store (STR)** instructions.
    - Other instructions operate on **registers**.

### **PC-Relative Addressing**

- ARM 64 uses **Program Counter-relative addressing** to calculate addresses dynamically.
- **Benefit**:
    - Enables **Position-Independent Code (PIC)**.
    - Allows programs to execute correctly regardless of where they are loaded in memory.
- **Key for Security**:
    - Supports **Address Space Layout Randomization (ASLR)**, which makes it harder for attackers to predict memory locations.

---

## **Common ARM 64 Instructions**

### **MOV**

- **Purpose**: Transfers a value between registers or into a register.
- **Syntax**:
    - `MOV X0, X1`: Move value of `X1` into `X0`.
    - `MOV X0, #1`: Move immediate value `1` into `X0`.

### **ADD**

- **Purpose**: Adds values and stores the result.
- **Syntax**:
    - `ADD X0, X1, X2`: Add `X1` and `X2`, result → `X0`.

### **LDR (Load Register)**

- **Purpose**: Loads data from **memory** into a register.
- **Modes**:
    1. **Pre-Indexing**: Update address **before** loading.
        - Example: `LDR X0, [X1, #10]!`
    2. **Post-Indexing**: Load first, then update the address.
        - Example: `LDR X0, [X1], #10`

### **STR (Store Register)**

- **Purpose**: Stores a value from a register into **memory**.
- **Syntax**:
    - `STR X0, [X1]`: Store `X0` at the memory location in `X1`.

### **SVC (Supervisor Call)**

- **Purpose**: Requests a system call from the operating system.
- **Syntax**: `SVC #0`
- **System Call Number**: Stored in **X16**.

---

## **ARM 64 Architecture Characteristics**

- **Reduced Instruction Set Computing (RISC)**:
    - Simpler instructions lead to **faster execution**.
- **Load-Store Model**:
    - Separation of memory access and computations improves performance.
- **32-bit Compatibility**:
    - Supports older systems through **AArch32** execution mode.
- **Power Efficiency**:
    - Designed for mobile devices to reduce **power consumption** and **heat generation**.
- **Security**:
    - Implements **ASLR** for randomizing memory addresses.

---

## **Summary**

This guide provides a detailed overview of the **ARM 64 architecture**, including:

- **Registers** and their purposes.
- **Calling conventions** and memory addressing.
- **Core instructions** used for computations, memory management, and branching.

This knowledge is crucial for reverse engineering, debugging binaries, and understanding how applications operate on Android devices.