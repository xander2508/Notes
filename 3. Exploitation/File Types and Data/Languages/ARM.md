## Calling Convention in ARM64
- **Argument Passing**:
  - First 8 arguments to a function are passed via registers **X0 to X7**.
  - Additional arguments are passed on the **stack**.
- **Return Value**:
  - Stored in **X0** for 64-bit results or **X0 + X1** for 128-bit results (e.g., large strings).
- **Function Return**:
  - **RET** instruction is used to return control to the caller via the **X30** (link) register.

## Branch Instructions
- **B**: Simple branch to a label (not a subroutine call).
- **BL (Branch with Link)**:
  - Copies the address of the next instruction into **X30**.
  - Used for subroutine calls to facilitate returning to the caller.
- **BR**:
  - Branches to the address stored in a specific register (e.g., `BR X8`).
- **BLR**:
  - Branches to the address in a specific register and updates **X30** with the return address.
- **RET**:
  - Returns control to the address in **X30**.

## ARM64 Registers Overview
- **General Purpose Registers**:
  - **X0–X7**: Argument registers for function calls and general-purpose use.
  - **X8–X28**: General-purpose registers for data/variables.
  - **X29**: Frame pointer (used to access local variables on the stack).
  - **X30**: Link register (stores return address after a function call).
  - **X31**: Dual-purpose register:
    - Can act as a **zero register** (constant zero).
    - Can function as the **stack pointer**.
- **Special Registers**:
  - **PC (Program Counter)**: Holds the address of the next instruction to execute.
  - **APSR & CPSR**: Store condition flags and processor state information.
  - **X16**: Used for passing system call numbers during **SVC** instructions.

## ARM64 Register Characteristics
- Registers prefixed with **X** are 64-bit.
- **W0–W30**: Lower 32-bit versions of corresponding **X** registers.
- Flexible usage of 32-bit and 64-bit registers without additional overhead.

## PC-Relative Addressing
- Calculates addresses relative to the current **PC** value using offsets.
- Enables generation of **position-independent code**.
- Crucial for shared libraries and dynamically loaded modules, improving security through **Address Space Layout Randomization (ASLR)**.

## Instructions Overview
- **MOVE**: Transfers values between registers (e.g., `MOV X0, X1`).
- **ADD**: Adds values in registers and stores the result in the first operand.
- **LDR (Load Register)**:
  - Loads data from memory address specified by a register (e.g., `LDR X0, [X1]`).
  - Supports **pre-indexing** (updates base register before loading) and **post-indexing** (updates base register after loading).
- **STR (Store Register)**:
  - Stores data from a register to a memory address specified by another register.
  - Destination is the address in the second operand.
- **ADR & ADRP**:
  - **ADR**: Generates a PC-relative address for nearby data.
  - **ADRP**: Generates a PC-relative address aligned to a page boundary, supporting larger offsets (~4 GB).

## System Call Handling
- **SVC Instruction**:
  - Invokes a system call using a number stored in **X16**.
  - Facilitates interaction with the operating system.

## ARM64 Architecture Key Features
- **RISC Architecture**:
  - Focuses on a reduced, optimized instruction set for simplicity and efficiency.
  - Improves performance and reduces power consumption.
- **Load-Store Architecture**:
  - Memory is accessed exclusively via specific instructions (e.g., LDR, STR).
- **Compatibility**:
  - Supports both **AR32 (32-bit)** and **AR64 (64-bit)** execution states for backward compatibility.
- **Mobile Suitability**:
  - Low transistor count reduces power consumption and heat generation.
  - Widely used in Android and iOS devices.

## Security Features
- **ASLR**:
  - Randomizes the memory layout of executables to protect against exploits.
- **PC-Relative Addressing**:
  - Supports position-independent code for enhanced security.

## Additional Notes
- **Instruction Syntax**:
  - First operand: **Destination** register.
  - Subsequent operands: **Source** registers.
- **Execution Context**:
  - Understanding ARM64 is crucial for reverse engineering, particularly for mobile devices and binary analysis.
- **ROPs (Return-Oriented Programming)**:
  - Knowledge of ARM64 assembly is vital for creating ROP chains.

This foundational understanding of ARM64 conventions, registers, and instructions provides the basis for exploring advanced topics like function prologues, epilogues, and binary reverse engineering.
